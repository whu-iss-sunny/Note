20181107
1.数组，结构体初始化为{0}
《The C++ Programming Language》
    数组可以用一个列值来初始化，例如
             int v1[] ={1,2,3,4};
             char v2[]={'a','b','c',0};
    当数组定义时没有指定大小，当初始化采用列表初始化了，那么数组的大小由初始化时列表元素个数决定。所以v1和v2分别为 int[4] 和char[4]类型。如果明确指定了数组大小，当在初始化时指定的元素个数超过这个大小就会产生错误。例如：
             char   v3[2] ={'a','b',0};   //错误：太多的初始化值了
             char   v3[3] ={'a','b',0};   //正确

    如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为   0。例如
             int   v5[8]={1,2,3,4};
    等价于
              int   v5[8]={1,2,3,4,0,0,0,0};
    顾名思义，集合（aggregate）就是多个事物聚集在一起，这个定义包括混合类型的集合：像struct和class等，数组就是单一类型的集合。
    初始化集合往往既冗长又容易出错，而C++中集合初始化（aggregate   initialization）却变得很方便而且很安全。当产生一个集合对象时，要做的只是指定初始值就行了，然后初始化工作就由编译器去承担了。这种指定可以用几种不同的风格，它取决于正在处理的集合类型。但不管是哪种情况，指定的初值都要用大括号括起来。比如一个内部类型的数组可以这样定义：
    int   a[5]   =   {   1,   2,   3,   4,   5   }；
    如果给出的初始化值多于数组元素的个数，编译器就会给出一条出错信息。但如果给的初始化少于数据元素的个数，那将会怎么样呢？例如：
    int   b[6]   =   {0};
    这时，编译器会把第一个初始化值赋给数组的第一个元素，然后用0赋给其余的元素。注意，如果定义了一个数组而没有给出一列初始值时，编译器并不会去做初始化工作。所以上面的表达式是将一个数组初始化为零的简洁方法，它不需要用一个for循环，也避免了“偏移1位”错误（它可能比for循环更有效，这取决于编译器）。
    数组还有一种叫自动计数（automatic   counting）的快速初始化方法，就是让编译器按初始化值的个数去决定数组的大小：
    int   c[   ]   =   {   1,   2,   3,   4   };
    现在，如果决定增加另一个元素到这个数组上，只要增加一个初始化值即可，如果以此建立我们的代码，只需在一处作出修改即可。这样，在修改时出错的机会就减少了。但怎样确定这个数组的大小呢？用表达式sizeof   c   /   sizeof   *c（整个数组的大小除以第一个元素的大小）即可算出，这样，当数组大小改变时它不需要修改。
    因为结构也是一种集合类型，所以它们也可以用同样的方式初始化。因为C风格的struct的所有成员都是public型的，所以它们的值可以直接指定。
    struct   X   {
    int   i;
    float   f;
    char   c;
    };
    X   x1   =   {   1，   2.2,   ‘c’   };
    如果有一个这种struct的数组，也可以用嵌套的大括号来初始化每一个对象：
    X   x2[3]   =   {   {1,   1.1,   ‘a’},   {2,   2.2,   ‘b’}};
    这里，第三个对象被初始化为零。
20181112
1.javaEE和j2EE
    一样的，只是叫法不一样了而已，J2EE 指的是 1.2～1.4 版本的，从 1.5 开始正式使用 Java EE 名字了，而且也不叫 1.5 了。
    Java EE 是J2EE的一个新的名称，之所以改名，目的还是让大家清楚J2EE只是Java企业应用。
    在2004年底中国软件技术大会Ioc微容器（也就是Jdon框架的实现原理）演讲中指出：我们需要一个跨J2SE/WEB/EJB的微容器.
    保护我们的业务核心组件（中间件），以延续它的生命力，而不是依赖J2SE/J2EE版本。
20181114
1.sqlserver 分布式
    分布式查询 建立链接服务器 Linked Server 即可
    分布式事务 MSDTC
   
2.CRC校验码
    采用CRC进行差错校验,生成多项式为G(x)=X^4+X+1,信息码字为10110.则计算出的CRC校验码是什么
    G(x)=X^4+X+1,即为10011（5位）,所以在数据后面添加5-1=4个0.
    则被除数是101100000,除数是10011,做模2运算.
    商10101,余数是1111(不足4位高位补0)
    于是冗余码FCS是1111
    将FCS加到数据码后面就得CRC码：101101111
    
3.研究了一下web的前后端分离
    个人理解这个前后端分离主要是指开发的分离 以及 对html控制分离（即页面渲染）
    所谓页面渲染指的是生成html文档的过程，并非浏览器渲染html
    模板解析(编译)和数据渲染。这两个步骤放在后端执行，则是像Smarty，FreeMarker这样的后端模板引擎；如果放在前端执行，就是我们所说的前端模板,如juicer。
    所以前后端分离后端只负责给前端提供数据和接口，前端负责整个页面的构造和加载
20181116
1.分布式数据库
    数据分片
        （1）水平分片：按一定的条件把全局关系的所有元组划分成若干不相交的子集，每个子集为关系的一个片段。（按行分）
        （2）垂直分片：把一个全局关系的属性集分成若干子集，并在这些子集上作投影运算，每个投影称为垂直分片。（按列分）
        （3）导出分片：又称为导出水平分片，即水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。
        （4）混合分片：以上三种方法的混合。可以先水平分片再垂直分片，或先垂直分片再水平分片，或其他形式，但他们的结果是不相同的。
    分片条件
        （1）完备性条件：必须把全局关系的所有数据映射到片段中，决不允许有属于全局关系的数据却不属于它的任何一个片段。
        （2）可重构条件：必须保证能够由同一个全局关系的各个片段来重建该全局关系。对于水平分片可用并操作重构全局关系；对于垂直分片可用联接操作重构全局关系。
        （3）不相交条件：要求一个全局关系被分割后所得的各个数据片段互不重叠（对垂直分片的主键除外）。
    分区、分表、分库
    分区：对业务透明，分区只不过把存放数据的文件分成了许多小块，例如mysql中的一张表对应三个文件.MYD,MYI,frm
    分片：对业务透明，在物理实现上分成多个服务器，不同的分片在不同服务器上
    分表：当数据量大到一定程度的时候，都会导致处理性能的不足，这个时候就没有办法了，只能进行分表处理。也就是把数据库当中数据根据按照分库原则分到多个数据表当中
          这样，就可以把大表变成多个小表，不同的分表中数据不重复，从而提高处理效率
          分表也有两种方案：
            1. 同库分表：所有的分表都在一个数据库中，由于数据库中表名不能重复，因此需要把数据表名起成不同的名字。
            优点：由于都在一个数据库中，公共表，不必进行复制，处理更简单
            缺点：由于还在一个数据库中，CPU、内存、文件IO、网络IO等瓶颈还是无法解决，只能降低单表中的数据记录数。
            　　　　　　表名不一致，会导后续的处理复杂（参照mysql meage存储引擎来处理）
            2. 不同库分表：由于分表在不同的数据库中，这个时候就可以使用同样的表名。
            优点：CPU、内存、文件IO、网络IO等瓶颈可以得到有效解决，表名相同，处理起来相对简单
            缺点：公共表由于在所有的分表都要使用，因此要进行复制、同步。
            　　　　一些聚合的操作，join,group by,order等难以顺利进行
    
    分库：分表和分区都是基于同一个数据库里的数据分离技巧，对数据库性能有一定提升，但是随着业务数据量的增加，
        原来所有的数据都是在一个数据库上的，网络IO及文件IO都集中在一个数据库上的，因此CPU、内存、文件IO、网络IO都可能会成为系统瓶颈。
        当业务系统的数据容量接近或超过单台服务器的容量、QPS/TPS接近或超过单个数据库实例的处理极限等
        此时，往往是采用垂直和水平结合的数据拆分方法，把数据服务和数据存储分布到多台数据库服务器上。
        分库只是一个通俗说法，更标准名称是数据分片，采用类似分布式数据库理论指导的方法实现，对应用程序达到数据服务的全透明和数据存储的全透明
    读写分离方案
        海量数据的存储及访问，通过对数据库进行读写分离，来提升数据的处理能力。读写分离它的方案特点是数据库产生多个副本，
        数据库的写操作都集中到一个数据库上，而一些读的操作呢，可以分解到其它数据库上。这样，只要付出数据复制的成本，
        就可以使得数据库的处理压力分解到多个数据库上，从而大大提升数据处理能力
    实现：分布式数据库中间件
          DBMS对分布式的支持
2.SQL server
    水平分片
        USE [DistributeTest]
        GO
        BEGIN TRANSACTION
        CREATE PARTITION FUNCTION [bgPartitionFun](int) AS RANGE LEFT FOR VALUES (N'10', N'20', N'30', N'40', N'50', N'60', N'70', N'80', N'90', N'100')

        CREATE PARTITION SCHEME [bgPartitionSchema] AS PARTITION [bgPartitionFun] TO ([PRIMARY], [ByidGroup1], [ByidGroup2], [ByidGroup3], [ByidGroup4], [ByidGroup5], [ByidGroup6], [ByidGroup7], [ByidGroup8], [ByidGroup9], [ByidGroup10])

        CREATE CLUSTERED INDEX [ClusteredIndex_on_bgPartitionSchema_636779753975580338] ON [dbo].[Test]
        (
            [ID]
        )WITH (SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF) ON [bgPartitionSchema]([ID])

        DROP INDEX [ClusteredIndex_on_bgPartitionSchema_636779753975580338] ON [dbo].[Test]

        COMMIT TRANSACTION
    垂直分片
        触发器
    垂直分库
        当数据库做了垂直分离后，因为每台业务数据库都分布在不同的屋里服务器上，通过 链接服务器+同义词今次那个跨库访问
20181217
    1.sqlserver 模糊查询
        like "%xxx%" "x%"
        charindex
        PATINDEX "%xxx%" "x%"
    2.视图能不能更新
    （1）若视图的字段是来自字段表达式或常数，则不允许对此视图执行INSERT、UPDATE操作，允许执行DELETE操作； 
    （2）若视图的字段是来自库函数，则此视图不允许更新； 
    （3）若视图的定义中有GROUP BY子句或聚集函数时，则此视图不允许更新； 
    （4）若视图的定义中有DISTINCT任选项，则此视图不允许更新； 
    （5）若视图的定义中有嵌套查询，并且嵌套查询的FROM子句中涉及的表也是导出该视图的基表，则此视图不允许更新； 
    （6）若视图是由两个以上的基表导出的，此视图不允许更新； 
    （7）一个不允许更新的视图上定义的视图也不允许更新； 
    （8）由一个基表定义的视图，只含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性，才允许更新。 
    （9）基本表的行列子集视图一般是可更新的。若视图的属性来自集函数、表达式，则该视图肯定是不可以更新的
20181221
    1.C#模拟web上传文件 https://www.cnblogs.com/yinq/p/6045995.html
        string fileContentStr = "--" + boundary + Enter
        + "Content-Type:application/octet-stream" + Enter
        + "Content-Disposition: form-data; name=\"fileContent\"; filename=\"" + fileName + "\"" + Enter + Enter;
        var fileContentStrByte = Encoding.UTF8.GetBytes(fileContentStr);//fileContent一些名称等信息的二进制（不包含文件本身）
    2.double.PositiveInfinity double.NegativeInfinity
        可以用于比较大小
    3.视图可以优化复杂查询效率
20181226
    1.SQL Server ANSI_NULLS 、QUOTED_IDENTIFIER 、ANSI_PADDING 
    这些是 SQL-92 设置语句，使 SQL Server 2000/2005 遵从 SQL-92 规则。
    当 SET QUOTED_IDENTIFIER 为 ON 时，标识符可以由双引号分隔，而文字必须由单引号分隔。当 SET QUOTED_IDENTIFIER 为 OFF 时，标识符不可加引号，且必须符合所有 Transact-SQL 标识符规则。
    SQL-92 标准要求在对空值进行等于 (=) 或不等于 (<>) 比较时取值为 FALSE。当 SET ANSI_NULLS 为 ON 时，即使 column_name 中包含空值，使用 WHERE column_name = NULL 的 SELECT 语句仍返回零行。即使 column_name 中包含非空值，使用 WHERE column_name <> NULL 的 SELECT 语句仍会返回零行。
    当 SET ANSI_NULLS 为 OFF 时，等于 (=) 和不等于 (<>) 比较运算符不遵从 SQL-92 标准。使用 WHERE column_name = NULL 的 SELECT 语句返回 column_name 中包含空值的行。使用 WHERE column_name <> NULL 的 SELECT 语句返回列中包含非空值的行。此外，使用 WHERE column_name <> XYZ_value 的 SELECT 语句返回所有不为 XYZ_value 也不为 NULL 的行
    SET ANSI_PADDING
    控制列如何存储长度比列的已定义大小短的值，以及如何存储 char、varchar、binary 和 varbinary 数据中含有尾随空格的值。
    如果 SET ANSI_PADDING 为 ON，则遵从与 char(n) 或 binary(n) NOT NULL 相同的规则。 如果 SET ANSI_PADDING 为 OFF，则遵从与 varchar 或 varbinary 相同的规则。